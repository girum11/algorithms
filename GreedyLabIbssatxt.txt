1.)	Let the term “start time” reference the lower bound on any given employee’s range of availability.  Similarly, let “end time” reference the upper bound on any given employee’s range of availability.  Pseudocode describing the process for each employee is given:SORT the employees to ascend according to their end times. DEFINE some int ‘savedStart’, INITIALIZE to initial start timeDEFINE some set ‘candidates’ to hold candidate employees with a fitting start time <= savedStartWHILE (the current employee’s end time is < final end time)FOR (all of the following [that is, to the right] employees)      IF (the employee’s start time is <= savedStart)           ADD the employee to the set ‘candidates’FIND the max of ‘candidates’ (that is, the employee with the largest end time.  Use some library method for this)SET savedStart to be that max employee’s end timeADD that max employee’s number to a running list of what the schedule’s going to beCLEAR the set ‘candidates’ITERATE over that max employeeOUTPUT the schedule2.)	Modifying this algorithm for the sake of an alternative, a slightly changed copy of the prior algorithm is given (assume the same definitions given above): SORT the employees to descend according to their start times. DEFINE some int ‘savedEnd’, INITIALIZE to initial end timeDEFINE some set ‘candidates’ to hold candidate employees with a fitting end time >= savedEndWHILE (the current employee’s start time is > final start time)FOR (all of the following [that is, to the right] employees)      IF (the employee’s end time is >= savedEnd)           ADD the employee to the set ‘candidates’FIND the min of ‘candidates’ (that is, the employee with the smallest start time.  Use some library method for this)SET savedEnd to be that min employee’s start timeADD that min employee’s number to a running list of what the schedule’s going to beCLEAR the set ‘candidates’ITERATE over that min employeeFLIP the scheduleOUTPUT the schedule3.)  Proof:  Understand that in order to choose a minimum number of employees, employees must be chosen such that they cover the most amount of [units time] as is possible.Assume that there is a non-greedy choice S for any given choice of employees that ends up “covering more ground” than the greedy choice, that is, spans more [units time].  Let AG denote the employee that has the greatest ending time that still fits with the starting time rules.  Consider then the non-greedy choice S:S = (A1, A2, …… , An), where A1 ends earlier than AG does.Observe that we may replace A1 with AG and come up with a schedule S’ that covers a greater portion of the total time required with the same number of choices A.  This is true because AG ends at a greater time than A1 does, by supposition.Thus, no matter what non-greedy choice we take for A1, the greedy choice of taking the employee with the largest end time will always result in a choice with a larger amount of time covered with the same number of choices A, even possibly resulting in a fewer overall number of choices needed to span the entire range.Since this case holds true WLOG, every solution S can have an optimal solution generated from its greedy choices.(This proof may be reversed, where you start from the right side and look for the smallest starting point.)QED 4.)  i.) Stepping through my first algorithm, I get the employees 1, 4, 2.        ii.) Stepping through the second, I get the employees 3, 5, 6.	Both of these are optimal solutions.5.)	I would say that my particular algorithm is O(n2).  Consider the first algorithm (and apply a minor reversal for this to apply to the second).  Since each employee must take into account every employee that can potentially start either when he gets off, or before he gets off, each employee must search for a candidate that can take his place when he gets off.  Coming up that candidate list takes O(n-m), where m is the current employee’s place in line which is just O(n).  Now, since big-O notation is defined to be the worst case, I can assume that the worst case is when I can skip none of the employees, and must use all of them.  Then, I must consider n employees, and each one searches its own (n-m) subarray of employees for ‘compatible’ matches.  This ends up being O(n2), eclipsing the O(nlogn) we needed to search. Girum Ibssa	Greedy Lab	CSC 349		Professor Clint Staley